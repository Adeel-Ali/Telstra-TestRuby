# telstra_messaging_api
#
# This file was automatically generated by APIMATIC v2.0
# ( https://apimatic.io ).

module TelstraMessagingApi
  # MessagingController
  class MessagingController < BaseController
    @instance = MessagingController.new

    class << self
      attr_accessor :instance
    end

    def instance
      self.class.instance
    end

    # Send an SMS Message to a single or multiple mobile number/s.
    # @param [SendSMSRequest] payload Required parameter: A JSON or XML payload
    # containing the recipient's phone number and text message. This number can
    # be in international format if preceeded by a '+' or in national format
    # ('04xxxxxxxx') where x is a digit.
    # @return MessageSentResponse response from the API call
    def create_send_sms(payload)
      # Prepare query url.
      _query_builder = Configuration.base_uri.dup
      _query_builder << '/messages/sms'
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'content-type' => 'application/json; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.post(
        _query_url,
        headers: _headers,
        parameters: payload.to_json
      )
      OAuth2.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _context.response.status_code == 400
        raise APIException.new(
          'Invalid or missing request parameters TO-MSISDN-NOT-VALID' \
          ' SENDER-MISSING DELIVERY-IMPOSSIBLE' \
          ' FROM-MSISDN-TOO-LONG BODY-TOO-LONG BODY-MISSING' \
          ' TO-MSISDN-TOO-LONG TECH-ERR BODY-NOT-VALID' \
          ' NOT-PROVISIONED Request flagged as containing' \
          ' suspicious content ',
          _context
        )
      elsif _context.response.status_code == 401
        raise APIException.new(
          'Invalid access token. Please try with a valid token',
          _context
        )
      elsif _context.response.status_code == 403
        raise APIException.new(
          'Authorization credentials passed and accepted but account does' \
          ' not have permission SpikeArrest-The API call rate' \
          ' limit has been exceeded ',
          _context
        )
      elsif _context.response.status_code == 404
        raise APIException.new(
          'The requested URI does not exist RESOURCE-NOT-FOUND ',
          _context
        )
      elsif _context.response.status_code == 405
        raise APIException.new(
          'The requested resource does not support the supplied verb',
          _context
        )
      elsif _context.response.status_code == 415
        raise APIException.new(
          'API does not support the requested content type',
          _context
        )
      elsif _context.response.status_code == 422
        raise APIException.new(
          'The request is formed correctly, but due to some condition the' \
          ' request cannot be processed e.g. email is required and' \
          ' it is not provided in the request ',
          _context
        )
      elsif _context.response.status_code == 500
        raise APIException.new(
          'Technical error : Unable to route the message to a Target' \
          ' Endpoint : An error has occurred while processing your' \
          ' request, please refer to API Docs for summary on the' \
          ' issue ',
          _context
        )
      elsif _context.response.status_code == 501
        raise APIException.new(
          'The HTTP method being used has not yet been implemented for the' \
          ' requested resource ',
          _context
        )
      elsif _context.response.status_code == 503
        raise APIException.new(
          'The service requested is currently unavailable',
          _context
        )
      end
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'An internal error occurred when processing the request',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      MessageSentResponse.from_hash(decoded)
    end

    # Messages are retrieved one at a time, starting with the earliest response.
    # The API supports the encoding of the full range of emojis in the reply
    # message. The emojis will be in their UTF-8 format.
    # If the subscription has a `notifyURL`, response messages will be logged
    # there instead.
    # # Notification URL Format for SMS Response
    # <pre><code class="language-sh">{
    #   "to":"+61472880123",
    #   "from":"+61412345678",
    #   "body":"Foo4",
    #   "sentTimestamp":"2018-04-20T14:24:35",
    #   "messageId":"DMASApiA0000000146"
    # }</code></pre>
    # The fields are:
    # | Field | Description |
    # | --- |--- |
    # | `to` | The number the message was sent to. |
    # | `from` | The number the message was sent from. |
    # | `body` | The content of the SMS response. |
    # | `sentTimestamp` | Time handling of the message ended. |
    # | `messageId` | The ID assigned to the message. |
    # @return InboundPollResponse response from the API call
    def retrieve_sms_responses
      # Prepare query url.
      _query_builder = Configuration.base_uri.dup
      _query_builder << '/messages/sms'
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.get(
        _query_url,
        headers: _headers
      )
      OAuth2.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _context.response.status_code == 400
        raise APIException.new(
          'Invalid or missing request parameters NOT-PROVISIONED Request' \
          ' flagged as containing suspicious content ',
          _context
        )
      elsif _context.response.status_code == 401
        raise APIException.new(
          'Invalid access token. Please try with a valid token',
          _context
        )
      elsif _context.response.status_code == 403
        raise APIException.new(
          'Authorization credentials passed and accepted but account does' \
          ' not have permission SpikeArrest-The API call rate' \
          ' limit has been exceeded ',
          _context
        )
      elsif _context.response.status_code == 404
        raise APIException.new(
          'The requested URI does not exist RESOURCE-NOT-FOUND ',
          _context
        )
      elsif _context.response.status_code == 405
        raise APIException.new(
          'The requested resource does not support the supplied verb',
          _context
        )
      elsif _context.response.status_code == 415
        raise APIException.new(
          'API does not support the requested content type',
          _context
        )
      elsif _context.response.status_code == 422
        raise APIException.new(
          'The request is formed correctly, but due to some condition the' \
          ' request cannot be processed e.g. email is required and' \
          ' it is not provided in the request ',
          _context
        )
      elsif _context.response.status_code == 500
        raise APIException.new(
          'Technical error : Unable to route the message to a Target' \
          ' Endpoint : An error has occurred while processing your' \
          ' request, please refer to API Docs for summary on the' \
          ' issue ',
          _context
        )
      elsif _context.response.status_code == 501
        raise APIException.new(
          'The HTTP method being used has not yet been implemented for the' \
          ' requested resource ',
          _context
        )
      elsif _context.response.status_code == 503
        raise APIException.new(
          'The service requested is currently unavailable',
          _context
        )
      end
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'An internal error occurred when processing the request',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      InboundPollResponse.from_hash(decoded)
    end

    # If no notification URL has been specified, it is possible to poll for the
    # message status.
    # Note that the `MessageId` that appears in the URL must be URL encoded.
    # Just copying the `MessageId` as it was supplied when submitting the
    # message may not work.
    # SMS Status with Notification URL
    # ---
    # When a message has reached its final state, the API will send a POST to
    # the URL that has been previously specified.
    # <pre><code class="language-sh">{
    #     to: '+61418123456'
    #     sentTimestamp: '2017-03-17T10:05:22+10:00'
    #     receivedTimestamp: '2017-03-17T10:05:23+10:00'
    #     messageId: /cccb284200035236000000000ee9d074019e0301/1261418123456
    #     deliveryStatus: DELIVRD
    #   }
    # </code></pre>
    # The fields are:
    # <table>
    #   <thead>
    #     <tr>
    #       <th>Field</th>
    #       <th>Description</th>
    #     </tr>
    #   </thead>
    #   <tbody>
    #     <tr>
    #       <td><code>to</code></td>
    #       <td>The number the message was sent to.</td>
    #     </tr>
    #     <tr>
    #       <td><code>receivedTimestamp</code></td>
    #       <td>Time the message was sent to the API.</td>
    #     </tr>
    #     <tr>
    #       <td><code>sentTimestamp</code></td>
    #       <td>Time handling of the message ended.</td>
    #     </tr>
    #     <tr>
    #       <td><code>deliveryStatus</code></td>
    #       <td>The final state of the message.</td>
    #     </tr>
    #     <tr>
    #       <td><code>messageId</code></td>
    #       <td>The same reference that was returned when the original message
    # was sent.</td>
    #     </tr>
    #     <tr>
    #       <td><code>receivedTimestamp</code></td>
    #       <td>Time the message was sent to the API.</td>
    #     </tr>
    #   </tbody>
    # </table>
    # Upon receiving this call it is expected that your servers will give a 204
    # (No Content) response.
    # Anything else will cause the API to reattempt the call 5 minutes later.
    # @param [String] message_id Required parameter: Unique identifier of a
    # message - it is the value returned from a previous POST call to
    # https://api.telstra.com/v2/messages/sms.
    # @return List of OutboundPollResponse response from the API call
    def get_sms_status(message_id)
      # Prepare query url.
      _query_builder = Configuration.base_uri.dup
      _query_builder << '/messages/sms/{messageId}/status'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'messageId' => message_id
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.get(
        _query_url,
        headers: _headers
      )
      OAuth2.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _context.response.status_code == 400
        raise APIException.new(
          'Invalid or missing request parameters  NOT-PROVISIONED  Request' \
          ' flagged as containing suspicious content',
          _context
        )
      elsif _context.response.status_code == 401
        raise APIException.new(
          'Invalid access token. Please try with a valid token',
          _context
        )
      elsif _context.response.status_code == 403
        raise APIException.new(
          'Authorization credentials passed and accepted but account does' \
          ' not have permission  SpikeArrest-The API call rate' \
          ' limit has been exceeded',
          _context
        )
      elsif _context.response.status_code == 404
        raise APIException.new(
          'The requested URI does not exist  OLD-NONEXISTANT-MESSAGE-ID ' \
          ' RESOURCE-NOT-FOUND',
          _context
        )
      elsif _context.response.status_code == 405
        raise APIException.new(
          'The requested resource does not support the supplied verb',
          _context
        )
      elsif _context.response.status_code == 415
        raise APIException.new(
          'API does not support the requested content type',
          _context
        )
      elsif _context.response.status_code == 422
        raise APIException.new(
          'The request is formed correctly, but due to some condition the' \
          ' request cannot be processed e.g. email is required and' \
          ' it is not provided in the request ',
          _context
        )
      elsif _context.response.status_code == 500
        raise APIException.new(
          'Technical error : Unable to route the message to a Target' \
          ' Endpoint : An error has occurred while processing your' \
          ' request, please refer to API Docs for summary on the' \
          ' issue ',
          _context
        )
      elsif _context.response.status_code == 501
        raise APIException.new(
          'The HTTP method being used has not yet been implemented for the' \
          ' requested resource ',
          _context
        )
      elsif _context.response.status_code == 503
        raise APIException.new(
          'The service requested is currently unavailable',
          _context
        )
      end
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'An internal error occurred when processing the request',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      decoded.map { |element| OutboundPollResponse.from_hash(element) }
    end

    # Send MMS
    # @param [SendMMSRequest] body Required parameter: A JSON or XML payload
    # containing the recipient's phone number and MMS message. The recipient
    # number should be in the format '04xxxxxxxx' where x is a digit.
    # @return MessageSentResponse response from the API call
    def create_send_mms(body)
      # Prepare query url.
      _query_builder = Configuration.base_uri.dup
      _query_builder << '/messages/mms'
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json',
        'content-type' => 'application/json; charset=utf-8'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.post(
        _query_url,
        headers: _headers,
        parameters: body.to_json
      )
      OAuth2.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _context.response.status_code == 400
        raise APIException.new(
          'Invalid or missing request parameters MMS-TYPE-MISSING' \
          ' MMS-PAYLOAD-MISSING MMS-FILENAME-MISSING' \
          ' DELIVERY-IMPOSSIBLE TO-MSISDN-NOT-VALID SENDER-MISSING' \
          ' DELIVERY-IMPOSSIBLE SUBJECT-TOO-LONG' \
          ' FROM-MSISDN-TOO-LONG TO-MSISDN-TOO-LONG' \
          ' NOT-PROVISIONED Request flagged as containing' \
          ' suspicious content ',
          _context
        )
      elsif _context.response.status_code == 401
        raise APIException.new(
          'Invalid access token. Please try with a valid token',
          _context
        )
      elsif _context.response.status_code == 403
        raise APIException.new(
          'Authorization credentials passed and accepted but account does' \
          ' not have permission SpikeArrest-The API call rate' \
          ' limit has been exceeded ',
          _context
        )
      elsif _context.response.status_code == 404
        raise APIException.new(
          'The requested URI does not exist RESOURCE-NOT-FOUND ',
          _context
        )
      elsif _context.response.status_code == 405
        raise APIException.new(
          'The requested resource does not support the supplied verb',
          _context
        )
      elsif _context.response.status_code == 415
        raise APIException.new(
          'API does not support the requested content type',
          _context
        )
      elsif _context.response.status_code == 422
        raise APIException.new(
          'The request is formed correctly, but due to some condition the' \
          ' request cannot be processed e.g. email is required and' \
          ' it is not provided in the request ',
          _context
        )
      elsif _context.response.status_code == 500
        raise APIException.new(
          'Technical error : Unable to route the message to a Target' \
          ' Endpoint : An error has occurred while processing your' \
          ' request, please refer to API Docs for summary on the' \
          ' issue ',
          _context
        )
      elsif _context.response.status_code == 501
        raise APIException.new(
          'The HTTP method being used has not yet been implemented for the' \
          ' requested resource ',
          _context
        )
      elsif _context.response.status_code == 503
        raise APIException.new(
          'The service requested is currently unavailable',
          _context
        )
      end
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'An internal error occurred when processing the request',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      MessageSentResponse.from_hash(decoded)
    end

    # Messages are retrieved one at a time, starting with the earliest response.
    # If the subscription has a `notifyURL`, response messages will be logged
    # there instead.
    # # Notification URL Format for MMS Replies
    # <pre><code class="language-sh">{
    #   "status": "RECEIVED",
    #   "destinationAddress": "+61418123456",
    #   "senderAddress": "+61421987654",
    #   "subject": "Foo",
    #   "sentTimestamp": "2018-03-23T12:15:45+10:00",
    #   "envelope": "string",
    #   "MMSContent":
    #     [
    #       {
    #         "type": "text/plain",
    #         "filename": "text_1.txt",
    #         "payload": "string"
    #       },
    #       {
    #         "type": "image/jpeg",
    #         "filename": "sample.jpeg",
    #         "payload": "string"
    #       }
    #     ]
    # }</code></pre>
    # The fields are:
    # | Field | Description |
    # | --- | --- |
    # | `status` | The final state of the message. |
    # | `destinationAddress` |The number the message was sent to. |
    # | `senderAddress` | The number the message was sent from. |
    # | `subject` | The subject assigned to the message. |
    # | `sentTimestamp` | Time handling of the message ended. |
    # | `envelope` | Information about about terminal type and originating
    # operator. |
    # | `MMSContent` | An array of the actual content of the reply message. |
    # | `type` | The content type of the message. |
    # | `filename` | The filename for the message content. |
    # | `payload` | The content of the message. |
    # @return List of MMSContent response from the API call
    def retrieve_mms_responses
      # Prepare query url.
      _query_builder = Configuration.base_uri.dup
      _query_builder << '/messages/mms'
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.get(
        _query_url,
        headers: _headers
      )
      OAuth2.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _context.response.status_code == 400
        raise APIException.new(
          'Invalid or missing request parameters NOT-PROVISIONED Request' \
          ' flagged as containing suspicious content ',
          _context
        )
      elsif _context.response.status_code == 401
        raise APIException.new(
          'Invalid access token. Please try with a valid token',
          _context
        )
      elsif _context.response.status_code == 403
        raise APIException.new(
          'Authorization credentials passed and accepted but account does' \
          ' not have permission SpikeArrest-The API call rate' \
          ' limit has been exceeded ',
          _context
        )
      elsif _context.response.status_code == 404
        raise APIException.new(
          'The requested URI does not exist RESOURCE-NOT-FOUND ',
          _context
        )
      elsif _context.response.status_code == 405
        raise APIException.new(
          'The requested resource does not support the supplied verb',
          _context
        )
      elsif _context.response.status_code == 415
        raise APIException.new(
          'API does not support the requested content type',
          _context
        )
      elsif _context.response.status_code == 422
        raise APIException.new(
          'The request is formed correctly, but due to some condition the' \
          ' request cannot be processed e.g. email is required and' \
          ' it is not provided in the request ',
          _context
        )
      elsif _context.response.status_code == 500
        raise APIException.new(
          'Technical error : Unable to route the message to a Target' \
          ' Endpoint : An error has occurred while processing your' \
          ' request, please refer to API Docs for summary on the' \
          ' issue ',
          _context
        )
      elsif _context.response.status_code == 501
        raise APIException.new(
          'The HTTP method being used has not yet been implemented for the' \
          ' requested resource ',
          _context
        )
      elsif _context.response.status_code == 503
        raise APIException.new(
          'The service requested is currently unavailable',
          _context
        )
      end
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'An internal error occurred when processing the request',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      decoded.map { |element| MMSContent.from_hash(element) }
    end

    # Get MMS Status
    # @param [String] messageid Required parameter: Unique identifier of a
    # message - it is the value returned from a previous POST call to
    # https://api.telstra.com/v2/messages/mms
    # @return List of OutboundPollResponse response from the API call
    def get_mms_status(messageid)
      # Prepare query url.
      _query_builder = Configuration.base_uri.dup
      _query_builder << '/messages/mms/{messageid}/status'
      _query_builder = APIHelper.append_url_with_template_parameters(
        _query_builder,
        'messageid' => messageid
      )
      _query_url = APIHelper.clean_url _query_builder

      # Prepare headers.
      _headers = {
        'accept' => 'application/json'
      }

      # Prepare and execute HttpRequest.
      _request = @http_client.get(
        _query_url,
        headers: _headers
      )
      OAuth2.apply(_request)
      _context = execute_request(_request)

      # Validate response against endpoint and global error codes.
      if _context.response.status_code == 400
        raise APIException.new(
          'Invalid or missing request parameters  NOT-PROVISIONED  Request' \
          ' flagged as containing suspicious content',
          _context
        )
      elsif _context.response.status_code == 401
        raise APIException.new(
          'Invalid access token. Please try with a valid token',
          _context
        )
      elsif _context.response.status_code == 403
        raise APIException.new(
          'Authorization credentials passed and accepted but account does' \
          ' not have permission SpikeArrest-The API call rate' \
          ' limit has been exceeded ',
          _context
        )
      elsif _context.response.status_code == 404
        raise APIException.new(
          'The requested URI does not exist OLD-NONEXISTANT-MESSAGE-ID' \
          ' RESOURCE-NOT-FOUND ',
          _context
        )
      elsif _context.response.status_code == 405
        raise APIException.new(
          'The requested resource does not support the supplied verb',
          _context
        )
      elsif _context.response.status_code == 415
        raise APIException.new(
          'API does not support the requested content type',
          _context
        )
      elsif _context.response.status_code == 422
        raise APIException.new(
          'The request is formed correctly, but due to some condition the' \
          ' request cannot be processed e.g. email is required and' \
          ' it is not provided in the request ',
          _context
        )
      elsif _context.response.status_code == 500
        raise APIException.new(
          'Technical error : Unable to route the message to a Target' \
          ' Endpoint : An error has occurred while processing your' \
          ' request, please refer to API Docs for summary on the' \
          ' issue ',
          _context
        )
      elsif _context.response.status_code == 501
        raise APIException.new(
          'The HTTP method being used has not yet been implemented for the' \
          ' requested resource ',
          _context
        )
      elsif _context.response.status_code == 503
        raise APIException.new(
          'The service requested is currently unavailable',
          _context
        )
      end
      unless _context.response.status_code.between?(200, 208)
        raise APIException.new(
          'An internal error occurred when processing the request',
          _context
        )
      end
      validate_response(_context)

      # Return appropriate response type.
      decoded = APIHelper.json_deserialize(_context.response.raw_body)
      decoded.map { |element| OutboundPollResponse.from_hash(element) }
    end
  end
end
